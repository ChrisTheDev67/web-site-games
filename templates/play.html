{% extends "base.html" %}

{% block head %}
<!-- CSS -->
<link rel="stylesheet" href="https://pyscript.net/releases/2024.11.1/core.css">
<!-- JS -->
<script type="module" src="https://pyscript.net/releases/2024.11.1/core.js"></script>
{% endblock %}

{% block content %}
<div class="game-container">
    <div class="game-header">
        <h2>Playing: {{ game_id }}</h2>
        <a href="{{ url_for('games') }}" class="back-btn">‚Üê Back to Gallery</a>
    </div>

    <div class="game-viewport">
        <!-- Allows PyScript to output here -->
        <div id="terminal" class="terminal-output"></div>
        <!-- Canvas for graphical games -->
        <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <div id="game-status" style="color: white; text-align: center; margin-bottom: 10px; font-family: monospace;">
        Initializing...</div>

    <!-- Game Loader Script -->
    <script type="py" terminal>
        import asyncio
        import os
        import js
        from pyodide.http import pyfetch
        import micropip

        def set_status(msg):
            print(f"> {msg}")
            status_el = js.document.getElementById("game-status")
            if status_el:
                status_el.innerText = msg

        # Data passed from Jinja
        GAME_ID = "{{ game_id }}"
        FILES = {{ files_list | tojson }}
        # Use absolute path for assets on Vercel to avoid path resolution issues
        BASE_URL = js.window.location.origin + f"/static/games/{GAME_ID}"
        
        async def fetch_and_save_file(filename):
            url = f"{BASE_URL}/{filename}"
            set_status(f"Downloading {filename}...")
            try:
                response = await pyfetch(url)
                if response.status == 200:
                    content = await response.bytes()
                    dir_name = os.path.dirname(filename)
                    if dir_name:
                        os.makedirs(dir_name, exist_ok=True)
                    with open(filename, 'wb') as f:
                        f.write(content)
                else:
                    set_status(f"Error {response.status}: {filename}")
            except Exception as e:
                set_status(f"Load Error {filename}: {e}")

        async def start_game():
            try:
                set_status("Initializing Pyodide...")
                
                # Check for existing main.py to prevent re-downloads on refresh if needed
                # (though usually fresh env per load)
                
                set_status("Installing libraries...")
                try:
                    # Pygame-ce is generally the preferred version for web
                    await micropip.install("pygame-ce")
                except Exception as e:
                    set_status(f"pygame-ce install failed, trying fallback...")
                    await micropip.install("pygame")

                set_status("Fetching game assets...")
                
                # Download all files
                tasks = [fetch_and_save_file(f) for f in FILES]
                await asyncio.gather(*tasks)
                
                set_status("Assets ready. Launching game...")
                
                if os.path.exists("main.py"):
                    set_status("Running main.py...")
                    with open("main.py", "r") as f:
                        code = f.read()
                        
                    # Standard way to run a script in Pyodide with its own global scope
                    globs = globals().copy()
                    globs['__name__'] = '__main__'
                    exec(code, globs)
                    set_status("Game is active")
                else:
                    set_status("Critical Error: main.py missing!")
                    js.alert("main.py was not found in the game folder.")
            except Exception as e:
                set_status(f"Runtime Exception: {e}")
                import traceback
                traceback.print_exc()

        # Start the async loader
        asyncio.ensure_future(start_game())
    </script>

</div>
{% endblock %}